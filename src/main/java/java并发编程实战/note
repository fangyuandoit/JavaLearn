无状态的对象一定是线程安全的

同步代码块（synchronized Block）包括两部分1：作为锁的对象应用  2：这个锁保护的代码块


重入：任意线程在获取到锁之后，再次获取该锁而不会被该锁所阻塞


调试小提示：对于服务器应用程序，无论开发阶段还是测试阶段，当启动jvm时一定要指定 -server 命令行选项。
server模式的jvm将比client模式的jvm进行了更多的优化，例如将循环中未被修改的变量提升到循环外部，
因此在开发环境（Client模式的jvm）中能够运行正确的代码，可能会在部署环境（server）模式中运行失败


对于volatile关键字，当且仅当满足以下所有条件时可使用：
1. 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。
2. 该变量没有包含在具有其他变量的不变式中。
3.在访问变量时不需要枷锁



volatile和synchronized的区别
volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的
volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性
volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化

加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性


由于Ad-hoc线程封闭技术的脆弱性，因此在程序中尽量的少用它，在可能的情况下，应该使用更强的线程封闭技术如栈封闭或ThreadLocal类


























